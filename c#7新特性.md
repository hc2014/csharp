## c#7.0

[MSDNc#7.0](https://docs.microsoft.com/zh-cn/dotnet/csharp/whats-new/csharp-7)

#### out变量

支持 `out` 参数的现有语法已在此版本中得到改进。The existing syntax that supports `out` parameters has been improved in this version.  以前，你需要将 out 变量的声明及其初始化分为两个不同的语句：

```c#
int numericResult;
if (int.TryParse(input, out numericResult))
    WriteLine(numericResult);
else
    WriteLine("Could not parse input");
```

现在可以在方法调用的参数列表中声明 `out` 变量，而不是编写单独的声明语句：

```c#
if (int.TryParse(input, out int result))
    WriteLine(result);
else
    WriteLine("Could not parse input");
```



#### 元组

测试例子先nuget安装 System.ValueTuple

低于 C# 7.0 的版本中也提供元组，但它们效率低下且不具有语言支持。Tuples were available before C# 7.0, but they were inefficient and had no language support. 这意味着元组元素只能作为 `Item1` 和 `Item2` 等引用。This meant that tuple elements could only be referenced as `Item1`, `Item2` and so on. C# 7.0 引入了对元组的语言支持，可利用更有效的新元组类型向元组字段赋予语义名称。

什么意思？

声明一个元组

```c#
var letters = ("a", "b");
```

如果没有安装ValueType的话想用元组可以直接这样写:

```c#
Tuple<int, string, object> t = Tuple.Create<int, string, object>(1, "1", 1);
```



原来版本的c# 调试`letters` 的时候，发现它两个变量的名称为Item1跟Item2，如果有第三个参数，那就是Item3，依次类推

在7.0以后 可以主动声明 元组元素的名称

```c#
//写法一
(string Alpha, string Beta) namedLetters = ("a", "b");
//写法二
var firstLetters = (Alpha: "a", Beta: "b");
//写法三，但是做成右侧的命名会被左侧给覆盖
(string First, string Second) firstLetters = (Alpha: "a", Beta: "b");
```

这样，元素a的名称就是Alpha，元素b的名称就是Beta



还可以为 .NET 中的任何类型提供类似的析构。这通过将 `Deconstruct` 方法编写为类的成员来完成。方法为你要提取的每个属性提供一组 `out` 参数。考虑提供析构函数方法的此 `Point` 类，该方法提取 `X` 和 `Y` 坐标：

> 关于 Deconstruct 关键字 可以自行百度

```c#
public class Point
{
    public Point(double x, double y)
    {
        this.X = x;
        this.Y = y;
    }

    public double X { get; }
    public double Y { get; }

    public void Deconstruct(out double x, out double y)
    {
        x = this.X;
        y = this.Y;
    }
}
```

可以通过向元组分配 `Point` 来提取各个字段：

```c#
var p = new Point(3.14, 2.71);
(double X, double Y) = p;
```

不会受到 `Deconstruct` 方法中定义的名称的约束。You are not bound by the names defined in the `Deconstruct` method. 可以在分配过程中重命名提取变量：You can rename the extract variables as part of the assignment: 

```c#
(double horizontalDistance, double verticalDistance) = p;
```



#### 弃元

通常，在进行元组解构或使用 `out` 参数调用方法时，必须定义一个其值无关紧要且你不打算使用的变量。 为处理此情况，C# 增添了对弃元的支持。弃元是一个名为 `_`（下划线字符）的只写变量，可向单个变量赋予要放弃的所有值。 弃元类似于未赋值的变量；不可在代码中使用弃元（赋值语句除外）。

在以下方案中支持弃元：

- 在对元组或用户定义的类型进行解构时。
- 在使用 out 参数调用方法时。
- 在使用 is 和 switch 语句匹配操作的模式中。
- 在要将某赋值的值显式标识为弃元时用作独立标识符。

以下示例定义了 `QueryCityDataForYears` 方法，它返回一个包含两个不同年份的城市数据的六元组。本例中，方法调用仅与此方法返回的两个人口值相关，因此在进行元组解构时，将元组中的其余值视为弃元。

```c#
public static void Main()
{
  var (_, _, _, pop1, _, pop2) = QueryCityDataForYears("New York City", 1960, 2010);

  Console.WriteLine($"Population change, 1960 to 2010: {pop2 - pop1:N0}");
  Console.ReadKey();
}

private static (string, double, int, int, int, int) QueryCityDataForYears(string name, int year1, int year2)
{
  int population1 = 0, population2 = 0;
  double area = 0;

  if (name == "New York City")
  {
    area = 468.48;
    if (year1 == 1960)
    {
      population1 = 7781984;
    }
    if (year2 == 2010)
    {
      population2 = 8175133;
    }
    return (name, area, year1, population1, year2, population2);
  }

  return ("", 0, 0, 0, 0, 0);
}
```

测试后发现只有`pop1`跟`pop1`有值



#### 模糊匹配

模糊匹配模式适用于`is`跟`swich`

我们以一个简单的方案为例。 我们将在此方案中添加功能，以便演示模式匹配表达式如何使处理不相关类型的算法变得简单。我们从计算多次掷骰数之和的方法开始：

```c#
public static int DiceSum(IEnumerable<int> values)
{
    return values.Sum();
}
```

你可能很快就发现，有时需要在某几次掷骰中骰子多于一个的情况下得出掷骰数总和. 输入序列的一部分可以是多个结果，而非单个数字：

```c#
public static int DiceSum2(IEnumerable<object> values)
{
    var sum = 0;
    foreach(var item in values)
    {
        if (item is int val)
            sum += val;
        else if (item is IEnumerable<object> subList)
            sum += DiceSum2(subList);
    }
    return sum;
}
```

如果分支多的时候，那就用swich

```c#
public static int DiceSum3(IEnumerable<object> values)
{
    var sum = 0;
    foreach (var item in values)
    {
        switch (item)
        {
            case int val:
                sum += val;
                break;
            case IEnumerable<object> subList:
                sum += DiceSum3(subList);
                break;
        }
    }
    return sum;
}
```

匹配表达式的语法与 `is` 表达式稍有不同，你可以在 `case` 表达式的开头声明类型和变量

匹配表达式也支持常量这样可以通过分离出简单 case 来节省时间：

```c#
public static int DiceSum4(IEnumerable<object> values)
{
    var sum = 0;
    foreach (var item in values)
    {
        switch (item)
        {
            case 0:
                break;
            case int val:
                sum += val;
                break;
            case IEnumerable<object> subList when subList.Any():
                sum += DiceSum4(subList);
                break;
            case IEnumerable<object> subList:
                break;
            case null:
                break;
            default:
                throw new InvalidOperationException("unknown item type");
        }
    }
    return sum;
}
```



#### Ref局部变量和返回结果

