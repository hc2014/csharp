#一、字符串驻留机制
```
string a = "5";
string b = "5";
bool flag = string.ReferenceEquals(a, b);//true
```
开始我以为string是引用类型,而引用类型地址之间的比较肯定是不相等的，但是实际上在C#中String有一个驻留池的东西，里面存放的都是程序中所有的字符串。
所以当一个字符串被赋值的时候，首先是去这个驻留中查找是否会有一样的值，如果有，那么直接把该对象的引用地址赋值给新对象，如果没有就创建一个新的。
但是如果换成new String()或者是StringBuilder生成字符串的方式 就会返回false
```
string a = "a";
string b = new string(new char[]{'a'});
bool flag = string.ReferenceEquals(a, b);//false 
```
StringBuilder创建字符串像直接引用驻留池中的引用地址 也是可以实现的,需要用到String的静态方法**Intern**
```
string a = "a123";
StringBuilder sb = new StringBuilder();
sb.Append("a").Append("123");
string b = string.Intern(sb.ToString());
 bool flag = string.ReferenceEquals(a, b);//true 
```

#二、关于try-catch-finally 返回值的问题
```
public int fun()
{
    int i = 1;
    try
    {
        string a = "1";
        int j = Convert.ToInt32(a);
        return ++i;
    }
    catch (Exception)
    {
        i = 3;
        return ++i;
    }
    finally
    {
       i++;
    }
}

```

开始我以为执行结果会是5，因为异常以后catch里面i=3;然后++i;此时i=4;然后再finally里面i++;所以i的值应该是5.调试的时候i的结果也确实是5。
然而最后的返回结果确实4.因为这里面有一个机制就是，在return返回的之前，就会把变量的值存起来，然后再finally里面不管怎么修改这个变量，那也只是在方法体
内有效果，除了方法体(返回值)后，最后返回的就是在return那时保存起来的值！

#三、自定义类的扩展方法(this)
自定义类的扩展方法实现起来非常的简单,比如说自定义一个返回数据类型的扩展方法
```
public static class MyClass
    {
       public static string MyGetType(this object obj)
        {
            return obj.GetType().ToString();
        }
    }
```

调用方式
```
 static void Main(string[] args)
        {
            string s = "123";
            s.MyGetType();
        }
```
MyGetType 参数的第一个关键字是this 第二个是 应用的类型(此处用的是object类型,那么该方法就适用于所有的类型)
扩展方法被定义为静态方法，但它们是通过实例方法语法进行调用的。必须声明为public，如果说类已经定义了一个同名方法,那么编译器在调用的时候回优先调用
类自己的方法
