#一、字符串驻留机制
```
string a = "5";
string b = "5";
bool flag = string.ReferenceEquals(a, b);//true
```
开始我以为string是引用类型,而引用类型地址之间的比较肯定是不相等的，但是实际上在C#中String有一个驻留池的东西，里面存放的都是程序中所有的字符串。
所以当一个字符串被赋值的时候，首先是去这个驻留中查找是否会有一样的值，如果有，那么直接把该对象的引用地址赋值给新对象，如果没有就创建一个新的。
但是如果换成new String()或者是StringBuilder生成字符串的方式 就会返回false
```
string a = "a";
string b = new string(new char[]{'a'});
bool flag = string.ReferenceEquals(a, b);//false 
```
StringBuilder创建字符串像直接引用驻留池中的引用地址 也是可以实现的,需要用到String的静态方法**Intern**
```
string a = "a123";
StringBuilder sb = new StringBuilder();
sb.Append("a").Append("123");
string b = string.Intern(sb.ToString());
 bool flag = string.ReferenceEquals(a, b);//true 
```

#二、关于try-chtch-finally 返回值的问题
```
public int fun()
{
    int i = 1;
    try
    {
        string a = "1";
        int j = Convert.ToInt32(a);
        return ++i;
    }
    catch (Exception)
    {
        i = 3;
        return ++i;
    }
    finally
    {
       i++;
    }
}

```

开始我以为执行结果会是5，因为异常以后catch里面i=3;然后++i;此时i=4;然后再finally里面i++;所以i的值应该是5.调试的时候i的结果也确实是5。
然而最后的返回结果确实4.因为这里面有一个机制就是，在return返回的之前，就会把变量的值存起来，然后再finally里面不管怎么修改这个变量，那也只是在方法体
内有效果，除了方法体(返回值)后，最后返回的就是在return那时保存起来的值！
